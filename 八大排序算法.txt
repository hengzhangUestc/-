冒泡排序   // 升序排序
for (int i = 0 ; i < a.length ; i ++) {
	for (int j = 0 ; j < a.length - 1- i ; j++) {
		if （a[j+1] > a[j]） {
			// 交换
		}
	}
}

选择排序    //  升序排序
for (int i = 0 ; i < a.length ; i ++) {
	for (int j = i+1 ; j < a.length  ; j++) {
		if （a[i] > a[j]） {
			// 交换
		}
	}
}
直接插入排序
for （int i= 1 ; i < a.length ; i ++） {
	int temp = a[i];
	int j = 0;
	for (j = i -1 ; j >= 0 && a[j] > temp ;j-- ) {
		a[j+1] = a[j];
	}
	a[j + 1] = temp;
}

快速排序
if（low >= high） {
	return;
}
int i = low ;
int j = high ;
while (i < j) {
 /*     关于快速排序法为什么一定要哨兵j 先出动的原因？
            如果选取最左边的数arr[left]作为基准数，那么先从右边开始可保证i,j在相遇时，相遇数是小于基准数的，
            交换之后temp所在位置的左边都小于temp。但先从左边开始,相遇数是大于基准数的，无法满足temp左边的数都小于它。
            所以进行扫描，要从基准数的对面开始。（注：左右相对来说，也可前后）*/
	while (i < j && a[j] >= a[low]){
		j--;
	}
	while (i< j && a[i] <= a[low]) {
		i++;
	}
	if(i< j) {
	   // 交换a[i] 和 a[j] 的值
	}
}
int temp = a[i];
a[i] = a[low];
a[low] = a[i];

quitsSort(a,0 , i-1);
quitSort(a, i , high);

归并排序
public static void merge(int [] a , int low , int high) {
	int middle = (low + high) / 2;
	if(high > low ) {
		merge(a , low ,middle-1);
		merge(a,middle,high);
		mergeSort(a,low ,high);
	}
} 
public static void mergeSort (int [] a , int low ,int high) {
	int [] temp = new int[high - low +1];
	int middle = (high - low) /2;
	int start = low ;
	int end = middle +1 ;
	int k = 0 ;
	while (start <= middle && end <= high) {
		if(a[start] < a[end]) {
			temp[k++] = a[start++];
		}else {
			temp[k++] = a[end++];
		}
	}
	while (start <= middle) {
		temp[k++] = a[start++];
	}
	while(end <=high) {
	 	temp[k++] = a[end++];
	}
	for(int i = 0 ; i < temp.length; i ++) {
		a[low +i] = temp[i];
	}
}
希尔排序
pulic static void shellSort (int [] a){
	for (int gap = a.length / 2 ; gap > 0 ; gap /= 2) {
		for (int i = gap , i < a.length ; i ++) {
			insertIn(a , gap ,i);
		}
	}
}
public static void insertIn(int [] a,int gap , int i) {
	int temp = a[i];
	int j;
	for(j = i - gap ; j>=0 && a[j] > temp; j -= gap  ) {
		a[j+gap] = a[j];
	}
	a[j + gap] = a[j];
}
堆排序
public static void heapSort (int [] a) {
	heapInsert(a);
	int size = a.length;
	while(size > 1) {
		swap(a,0 ,size-1);
		size--;
		heapify(a,0 ,size);
	}
}
public static void heapInsert(int [] a) {     //  给的数组的遍历形式是层序遍历
	for (int i = 0 ; i <a.length ; i ++) {    
		int current = i ; 
		int father = (current -1) / 2;
		while (a[current] > a[father]) {
			swap (a ,current,father);
			current = father;
			father = (current - 1) / 2;
		} 
	}
}
public static void swap (int[] a ,int i ,int j) {
	int temp = a[i];
	a[i] = a[j];
	a[j] = temp;
}

public static void heapify(int [] a ,int index , int size) {
	int left = 2 * index +1;
	int right = 2 * index +2;
	while (left < size) {
		int largest ; 
		if(right < size && a[right] > a[left]) {
			largest = right;
		}else {
			largest = left;
		}
	}
	if (a[index] > a[largest]) {
		break;
	}
	swap(a,index,largest);
	index = largest;
	left = 2 * index +1 ;
	right = 2 * index +2 ;
}

基数排序

public static void baseSort (int [] a) {
	int max = a[0];
	for (int i= 1 ; i <a.length ; i ++) {
		if (a[i] > max) {
			max = a[i];
		}
	}
	
	int time = 0 ;
	while (max > 0 ) {
		max /= 10;
		time++;
	}

	ArrayList<ArrayList<Integer>>  lists =  new ArrayList<>();
	for (int k = 0 ; k < 10 ;k ++) {
		ArrayList<Integer> list1 = new ArrayList<>();
		lists.add(list1);
	}

	for (int i = 0 ; i < time ; i ++) {
		for (int j = 0 ; j < a.length ; j++)  {
			int x  = a[j] % (int)Math.pow(10,i+1) /(int)Math.pow(10,i);
			ArrayList<Integer> list2 = lists.get(x);
			list2.add(a[j]);
			//  list2.set(x,list2);   更新指定的索引
		}

		int count = 0 ; 
		for (int i = 0 ; i < time ; i ++)  {
			while (lists.get(i).size > 0)  {
			ArrayList<Integer> list3 = lists.get(i);
			a[count ++] = list3.get(0);
			list3.remove(0); 
			}
		}
	}

	
}


